"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const _utils_1 = require("@ng-toolkit/_utils");
const test_1 = require("@schematics/angular/utility/test");
const config_1 = require("@schematics/angular/utility/config");
const dependencies_1 = require("@schematics/angular/utility/dependencies");
const outdent_1 = require("outdent");
const js_1 = require("@bugsnag/js");
const bugsnagClient = js_1.default('0b326fddc255310e516875c9874fed91');
function addUniversal(options) {
    if (!options.clientProject) {
        options.clientProject = options.project;
    }
    // Remove extra properties to avoid schema errors while running @nguniversal/express-engine schematic.
    const { disableBugsnag, http, directory, project } = options, optionsReduced = __rest(options, ["disableBugsnag", "http", "directory", "project"]);
    const expressOptions = optionsReduced;
    // Register bugsnag in order to catch and notify any rule error.
    bugsnagClient.config.beforeSend = (report) => {
        report.metaData = {
            subsystem: {
                package: 'universal',
                options: options
            }
        };
    };
    const templateSource = schematics_1.apply(schematics_1.url('./files'), [
        schematics_1.move(options.directory)
    ]);
    const rules = [];
    rules.push(removePreviousServerlessFiles(options));
    rules.push(schematics_1.mergeWith(templateSource, schematics_1.MergeStrategy.Overwrite));
    rules.push(applyExpressEngine(options, expressOptions));
    rules.push(applyPackageJsonScripts(options));
    rules.push(enhanceServerModule(options));
    rules.push(renameAndEnhanceBrowserModule(options));
    rules.push(updateWebpackConfig());
    rules.push(addWrappers(options));
    rules.push(applyOtherNgToolkitSchematics(options));
    rules.push(addPrerender(options));
    rules.push(editTSConfigFile(options));
    rules.push(addRobotFile(options));
    if (!options.disableBugsnag) {
        return _utils_1.applyAndLog(schematics_1.chain(rules), bugsnagClient);
    }
    else {
        return schematics_1.chain(rules);
    }
}
exports.default = addUniversal;
function getSourceRoot(tree, options) {
    const workspace = config_1.getWorkspace(tree);
    return `${workspace.projects[options.clientProject].sourceRoot}`;
}
function removePreviousServerlessFiles(options) {
    return (tree) => {
        const packageJsonSource = JSON.parse(test_1.getFileContent(tree, `package.json`));
        if (packageJsonSource.dependencies['@ng-toolkit/serverless']) {
            const ngToolkitSettings = _utils_1.getNgToolkitInfo(tree, options);
            tree.delete(`./local.${ngToolkitSettings.serverless.lambdaTS ? 'ts' : 'js'}`);
            tree.delete(`./server.ts`);
            tree.delete(`./webpack.server.config.js`);
        }
        return tree;
    };
}
function applyExpressEngine(options, expressOptions) {
    return (tree) => {
        let hasUniversalBuild = false;
        const workspace = config_1.getWorkspace(tree);
        const architect = workspace.projects[options.clientProject].architect;
        if (architect) {
            for (let builder in architect) {
                if (architect[builder].builder === '@angular-devkit/build-angular:server') {
                    hasUniversalBuild = true;
                }
            }
        }
        if (!hasUniversalBuild) {
            return schematics_1.externalSchematic('@nguniversal/express-engine', 'ng-add', expressOptions);
        }
        else {
            return schematics_1.noop();
        }
    };
}
function applyPackageJsonScripts(options) {
    return (tree) => {
        const serverPort = options.serverPort ? options.serverPort.toString() : '4000';
        tree.overwrite(`local.js`, test_1.getFileContent(tree, `local.js`).replace(/__distFolder__/g, 'dist/server').replace(/__serverPort__/g, serverPort));
        tree.overwrite(`${options.serverFileName}`, test_1.getFileContent(tree, `${options.serverFileName}`).replace(/\/\/ Start up the Node server.*/gs, '').replace('const app = express();', 'export const app = express();'));
        const pkgPath = `/package.json`;
        const buffer = tree.read(pkgPath);
        if (buffer === null) {
            throw new schematics_1.SchematicsException('Could not find package.json');
        }
        const pkg = JSON.parse(buffer.toString());
        pkg.scripts['server'] = 'node local.js';
        pkg.scripts['build:prod'] = 'npm run build:ssr';
        pkg.scripts['serve:ssr'] = 'node local.js';
        tree.overwrite(pkgPath, JSON.stringify(pkg, null, 2));
        _utils_1.addDependencyToPackageJson(tree, options, {
            type: dependencies_1.NodeDependencyType.Default,
            name: '@nguniversal/common',
            version: '8.1.0'
        });
        return tree;
    };
}
function enhanceServerModule(options) {
    return (tree) => {
        const serverModulePath = `/${getSourceRoot(tree, options)}/${options.appDir}/${options.rootModuleFileName}`;
        _utils_1.addImportStatement(tree, serverModulePath, 'ServerTransferStateModule', '@angular/platform-server');
        _utils_1.addToNgModule(tree, serverModulePath, 'imports', 'ServerTransferStateModule');
        return tree;
    };
}
function renameAndEnhanceBrowserModule(options) {
    return (tree) => {
        const browserModulePath = `/${getSourceRoot(tree, options)}/${options.appDir}/${options.appDir}.browser.module.ts`;
        const modulePath = `/${getSourceRoot(tree, options)}/${options.appDir}/${options.appDir}.module.ts`;
        const mainPath = `/${getSourceRoot(tree, options)}/main.ts`;
        // Create browser entry module
        _utils_1.createOrOverwriteFile(tree, browserModulePath, test_1.getFileContent(tree, modulePath).replace('AppModule', 'AppBrowserModule'));
        //c Change app.module.ts
        _utils_1.addImportStatement(tree, modulePath, 'CommonModule', '@angular/common');
        _utils_1.addToNgModule(tree, modulePath, 'imports', 'CommonModule');
        if (options.http) {
            _utils_1.addImportStatement(tree, modulePath, 'TransferHttpCacheModule', '@nguniversal/common');
            _utils_1.addImportStatement(tree, modulePath, 'HttpClientModule', '@angular/common/http');
            _utils_1.addToNgModule(tree, modulePath, 'imports', 'TransferHttpCacheModule');
            _utils_1.addToNgModule(tree, modulePath, 'imports', 'HttpClientModule');
        }
        // Change app.browser.module.ts
        _utils_1.removeFromNgModule(tree, browserModulePath, 'imports', `BrowserModule.withServerTransition({ appId: '${options.appId}' })`);
        _utils_1.removeFromNgModule(tree, browserModulePath, 'declarations');
        _utils_1.addImportStatement(tree, browserModulePath, 'AppModule', './app.module');
        _utils_1.addToNgModule(tree, browserModulePath, 'imports', 'AppModule');
        _utils_1.addImportStatement(tree, browserModulePath, 'BrowserTransferStateModule', '@angular/platform-browser');
        _utils_1.addToNgModule(tree, browserModulePath, 'imports', 'BrowserTransferStateModule');
        // Change entry in main.ts
        _utils_1.addImportStatement(tree, mainPath, 'AppBrowserModule', `./${options.appDir}/app.browser.module`);
        _utils_1.createOrOverwriteFile(tree, mainPath, test_1.getFileContent(tree, mainPath).replace('.bootstrapModule(AppModule)', '.bootstrapModule(AppBrowserModule)'));
        return tree;
    };
}
function updateWebpackConfig() {
    return (tree) => {
        const webpackConfig = test_1.getFileContent(tree, `./webpack.server.config.js`);
        let newWebpackConfig = webpackConfig.replace('output: {', `output: {\n\t\tlibraryTarget: 'commonjs2',`);
        // For some reason, this line was added on 8.1.0 of `@nguniversal/express-engine` package.
        // Commenting this line will let our serverless lambda to properly run.
        // const ngToolkitSettings = getNgToolkitInfo(tree, options);
        // if (ngToolkitSettings.serverless) {}
        const externalsRegex = new RegExp('externals: {((.|\n)*?)}');
        newWebpackConfig = newWebpackConfig.replace(externalsRegex, `externals: {\n\t\t\// './dist/server/main': 'require("./server/main")'\n\t}`);
        _utils_1.createOrOverwriteFile(tree, `./webpack.server.config.js`, newWebpackConfig);
        return tree;
    };
}
function addWrappers(options) {
    return (tree) => {
        const modulePath = `/${getSourceRoot(tree, options)}/${options.appDir}/${options.appDir}.module.ts`;
        _utils_1.addImportStatement(tree, modulePath, 'NgtUniversalModule', '@ng-toolkit/universal');
        _utils_1.addToNgModule(tree, modulePath, 'imports', 'NgtUniversalModule');
        // search for 'window' occurences and replace them with injected Window instance
        tree.getDir(`/${getSourceRoot(tree, options)}`).visit(visitor => {
            if (visitor.endsWith('.ts')) {
                let fileContent = test_1.getFileContent(tree, visitor);
                if (fileContent.match(/class.*{[\s\S]*?((?:[()'"`\s])localStorage)/)) {
                    _utils_1.addDependencyInjection(tree, visitor, 'localStorage', 'any', '@ng-toolkit/universal', 'LOCAL_STORAGE');
                    _utils_1.updateCode(tree, visitor, 'localStorage');
                    fileContent = test_1.getFileContent(tree, visitor);
                }
                if (fileContent.match(/class.*{[\s\S]*?((?:[()'"`\s])window)/)) {
                    _utils_1.addDependencyInjection(tree, visitor, 'window', 'Window', '@ng-toolkit/universal', 'WINDOW');
                    _utils_1.updateCode(tree, visitor, 'window');
                }
                // if (fileContent.match(/class.*{[\s\S]*?((?:[()'"`\s])document)/)) {
                //     addDependencyInjection(tree, visitor, 'document', 'Document', '@ng-toolkit/universal', 'NGT_DOCUMENT');
                //     updateCode(tree, visitor, 'document');
                // }
            }
        });
        return tree;
    };
}
/**
 * Applies other @ng-toolkit schematics if installed.
 * @param options the @ng-toolkit/universal schema
 */
function applyOtherNgToolkitSchematics(options) {
    return (tree) => {
        const ngToolkitSettings = _utils_1.getNgToolkitInfo(tree, options);
        ngToolkitSettings.universal = options;
        _utils_1.updateNgToolkitInfo(tree, ngToolkitSettings, options);
        let externals = [];
        // Run ng-add of @ng-toolkit/serverless schematic if serverless exists.
        if (ngToolkitSettings.serverless) {
            ngToolkitSettings.serverless.directory = options.directory;
            ngToolkitSettings.serverless.skipInstall = true;
            ngToolkitSettings.serverless.clientProject = options.clientProject;
            externals.push(schematics_1.externalSchematic('@ng-toolkit/serverless', 'ng-add', ngToolkitSettings.serverless));
        }
        else if (tree.exists(`${options.directory}/.firebaserc`)) {
            ngToolkitSettings.serverless = {};
            ngToolkitSettings.serverless.directory = options.directory;
            ngToolkitSettings.serverless.skipInstall = true;
            ngToolkitSettings.serverless.provider = 'firebase';
            ngToolkitSettings.serverless.clientProject = options.clientProject;
            externals.push(schematics_1.externalSchematic('@ng-toolkit/serverless', 'ng-add', ngToolkitSettings.serverless));
        }
        const workspace = config_1.getWorkspace(tree);
        const projectArchitect = workspace.projects[options.clientProject].architect;
        // Run ng-add of @ng-toolkit/pwa schematic if pwa exists.
        if (projectArchitect &&
            projectArchitect.build &&
            projectArchitect.build.configurations &&
            projectArchitect.build.configurations.production &&
            projectArchitect.build.configurations.production.serviceWorker != undefined) {
            if (!ngToolkitSettings.pwa) {
                ngToolkitSettings.pwa = {};
            }
            ngToolkitSettings.pwa.directory = options.directory;
            ngToolkitSettings.pwa.skipInstall = true;
            ngToolkitSettings.pwa.clientProject = options.clientProject;
            externals.push(schematics_1.externalSchematic('@ng-toolkit/pwa', 'ng-add', ngToolkitSettings.pwa));
        }
        if (externals.length > 0) {
            return schematics_1.chain(externals);
        }
        return tree;
    };
}
function addPrerender(options) {
    return (tree) => {
        // Add dependencies
        _utils_1.addDependencyToPackageJson(tree, options, {
            type: dependencies_1.NodeDependencyType.Default,
            name: 'domino',
            version: '^2.1.4'
        });
        // Add scripts
        const pkgPath = `package.json`;
        const buffer = tree.read(pkgPath);
        if (buffer === null) {
            throw new schematics_1.SchematicsException('Could not find package.json at addPrerender function');
        }
        const pkg = JSON.parse(buffer.toString());
        pkg.scripts['start:prerender'] = "npm run build:prerender & npm run serve:prerender";
        pkg.scripts['serve:prerender'] = 'node static.js';
        pkg.scripts['build:prerender'] = 'npm run build:prod && node dist/prerender.js';
        tree.overwrite(pkgPath, JSON.stringify(pkg, null, 2));
        // Add entry in webpack configuration
        const webpackConfig = test_1.getFileContent(tree, `./webpack.server.config.js`);
        _utils_1.createOrOverwriteFile(tree, `./webpack.server.config.js`, webpackConfig.replace(`server: './server.ts'`, `server: './server.ts',\n\t\tprerender: './prerender.ts'`));
        return tree;
    };
}
/**
 * Change the default `tsconfig.json` file to enable default imports for some JS packages.
 * Also set the module code generation to CommonJS to enable webpack typescript compilation and other stuff.
 * @param options serverless options schema
 */
function editTSConfigFile(options) {
    return tree => {
        const tsConfig = JSON.parse(test_1.getFileContent(tree, `${options.directory}/tsconfig.json`));
        tsConfig.compilerOptions['esModuleInterop'] = true;
        tsConfig.compilerOptions['allowSyntheticDefaultImports'] = true;
        tsConfig.compilerOptions['module'] = 'commonjs';
        tree.overwrite(`${options.directory}/tsconfig.json`, JSON.stringify(tsConfig, null, 2));
        return tree;
    };
}
function addRobotFile(options) {
    return (tree) => {
        // Create robots.txt file
        const robotFileContent = outdent_1.default `
			# Allow all URLs (see http://www.robotstxt.org/robotstxt.html)
			User-agent: *
			Allow: /
		`;
        _utils_1.createOrOverwriteFile(tree, `/${getSourceRoot(tree, options)}/robots.txt`, robotFileContent);
        // Load and edit angular.json file content  to include the robots.txt file
        const workspace = config_1.getWorkspace(tree);
        const projectArchitect = workspace.projects[options.clientProject].architect;
        if (projectArchitect) {
            const browserBuilder = projectArchitect.build;
            const testBuilder = projectArchitect.test;
            if (browserBuilder && browserBuilder.options.assets) {
                if (browserBuilder.options.assets.every(x => typeof x === 'string')) {
                    browserBuilder.options.assets.push(`${getSourceRoot(tree, options)}/robots.txt`);
                    projectArchitect.build = browserBuilder;
                }
            }
            if (testBuilder && testBuilder.options.assets) {
                if (testBuilder.options.assets.every(x => typeof x === 'string')) {
                    testBuilder.options.assets.push(`${getSourceRoot(tree, options)}/robots.txt`);
                    projectArchitect.test = testBuilder;
                }
            }
        }
        workspace.projects[options.clientProject].architect = projectArchitect;
        _utils_1.createOrOverwriteFile(tree, `${options.directory}/angular.json`, JSON.stringify(workspace, null, 2));
        return tree;
    };
}
//# sourceMappingURL=index.js.map