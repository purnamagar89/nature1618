"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const _utils_1 = require("@ng-toolkit/_utils");
const test_1 = require("@schematics/angular/utility/test");
const tasks_1 = require("@angular-devkit/schematics/tasks");
const outdent_1 = require("outdent");
const js_1 = require("@bugsnag/js");
const bugsnagClient = js_1.default('0b326fddc255310e516875c9874fed91');
function addPWA(options) {
    if (!options.clientProject) {
        options.clientProject = options.project;
    }
    // Register bugsnag in order to catch and notify any rule error.
    bugsnagClient.config.beforeSend = (report) => {
        report.metaData = {
            subsystem: {
                package: 'pwa',
                options: options
            }
        };
    };
    const rules = [];
    // Check if @angular/pwa was applied.
    rules.push((tree) => {
        const cliConfig = JSON.parse(test_1.getFileContent(tree, `${options.directory}/angular.json`));
        if (!cliConfig.projects[options.clientProject].architect.build.configurations.production.serviceWorker) {
            throw new _utils_1.NgToolkitException(`Run 'ng add @angular/pwa' before applying this schematics.`);
        }
        return tree;
    });
    // add entry to server module
    rules.push((tree) => {
        let serverModulePath = options.serverModule ? options.serverModule : findServerModule(tree, options);
        if (serverModulePath) {
            _utils_1.addImportStatement(tree, serverModulePath, 'NgtPwaMockModule', '@ng-toolkit/pwa');
            _utils_1.addToNgModule(tree, serverModulePath, 'imports', 'NgtPwaMockModule');
        }
        return tree;
    });
    rules.push((tree, context) => {
        const ngToolkitSettings = _utils_1.getNgToolkitInfo(tree, options);
        // Add update mechanism.
        if (!ngToolkitSettings.pwa) {
            let bootstrapComponent = _utils_1.getBootStrapComponent(tree, _utils_1.getAppEntryModule(tree, options).filePath)[0];
            let swUpdateVar = _utils_1.addDependencyInjection(tree, bootstrapComponent.filePath, 'swUpdate', 'SwUpdate', '@angular/service-worker');
            _utils_1.implementInterface(tree, bootstrapComponent.filePath, 'OnInit', '@angular/core');
            let methodBodyEdges = _utils_1.getMethodBodyEdges(tree, bootstrapComponent.filePath, 'ngOnInit');
            let fileContent = test_1.getFileContent(tree, bootstrapComponent.filePath);
            if (!methodBodyEdges) {
                _utils_1.addMethod(tree, bootstrapComponent.filePath, 'public ngOnInit():void {}');
                methodBodyEdges = _utils_1.getMethodBodyEdges(tree, bootstrapComponent.filePath, 'ngOnInit');
                fileContent = test_1.getFileContent(tree, bootstrapComponent.filePath);
            }
            if (methodBodyEdges) {
                fileContent = fileContent.substring(0, methodBodyEdges.start) + outdent_1.default `
                if (this.${swUpdateVar}.isEnabled) {
                    this.${swUpdateVar}.available.subscribe((evt) => {
                        console.log('service worker updated');
                    });
            
                    this.${swUpdateVar}.checkForUpdate().then(() => {
                        // noop
                    }).catch((err) => {
                        console.error('error when checking for update', err);
                    });
                }` + fileContent.substring(methodBodyEdges.end);
                _utils_1.createOrOverwriteFile(tree, bootstrapComponent.filePath, fileContent);
            }
        }
        ngToolkitSettings.pwa = options;
        _utils_1.updateNgToolkitInfo(tree, ngToolkitSettings, options);
        if (!options.skipInstall) {
            context.addTask(new tasks_1.NodePackageInstallTask(options.directory));
        }
        return tree;
    });
    if (!options.disableBugsnag) {
        return _utils_1.applyAndLog(schematics_1.chain(rules), bugsnagClient);
    }
    else {
        return schematics_1.chain(rules);
    }
}
exports.default = addPWA;
function findServerModule(tree, options) {
    let mainServerFilePath = _utils_1.getMainServerFilePath(tree, options);
    if (!mainServerFilePath) {
        console.log(`\u001B[33mINFO: \u001b[0mCan't find server build in angular.json; Use @ng-toolkit/universal for server-side rendering.`);
        return undefined;
    }
    let mainFileContent = test_1.getFileContent(tree, `${options.directory}/${mainServerFilePath}`);
    let match = mainFileContent.match(/export[\s\S]*?{[\s\S]*?}[\s\S]*?from[\s\S]*?['"](.*)['"]/);
    if (!match) {
        throw new _utils_1.NgToolkitException(`Can't find server app module in $${options.directory}/${mainServerFilePath}`, { fileContent: mainFileContent });
    }
    return _utils_1.normalizePath(`${options.directory}/${mainServerFilePath.substring(0, mainServerFilePath.lastIndexOf('/'))}/${match[1]}.ts`);
}
//# sourceMappingURL=index.js.map